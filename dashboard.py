# Form implementation generated from reading ui file 'dashboard.ui'
#
# Created by: PyQt6 UI code generator 6.6.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.
import os
from datetime import timedelta

from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import QVBoxLayout, QHBoxLayout, QStackedWidget, QWidget, QTableWidget, QFrame, QPushButton, \
    QHeaderView, QDialog, QFileDialog, QTimeEdit, QMessageBox, QComboBox
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
import matplotlib.gridspec as gridspec
import create_METCM, metmessage
import create_METTA
import dash_load
import loading_page
import profilegenerator
import time_zone_finder

df: ''
input_header = []
input_table = []
output_directory = ''
change_flag = 0
file_list = []
time_zone = ''
input_time = []
tables = []
headers = []
output_files = []

class FileManagerDialog(QDialog):
    def __init__(self):
        super().__init__()
        self.save_file_dialog()

    def save_file_dialog(self):
        global browsed_files, output_directory
        try:
            dialog = QFileDialog(self)
            dialog.setFileMode(QFileDialog.FileMode.AnyFile)  # Allow selecting any file type
            dialog.setAcceptMode(QFileDialog.AcceptMode.AcceptSave)  # Set to save mode
            dialog.setOption(QFileDialog.Option.ShowDirsOnly, True)  # Only show directories
            dialog.setNameFilter("Text files (*.txt)")  # Set filter to show only txt files
            if dialog.exec() == QDialog.DialogCode.Accepted:
                if metmessage.selected_format == 1:
                    create_METCM.acceptance_flag = 0
                    selected_directory = dialog.selectedFiles()[0]
                    file_name = dialog.selectedNameFilter()  # Get the specified file name
                    if selected_directory:
                        selected_file = selected_directory + '/' + file_name
                    output_directory = selected_file.replace('/Text files (*.txt)', '')
                elif metmessage.selected_format == 2:
                    create_METTA.acceptance_flag = 0
                    selected_directory = dialog.selectedFiles()[0]
                    file_name = dialog.selectedNameFilter()  # Get the specified file name
                    if selected_directory:
                        selected_file = selected_directory + '/' + file_name
                    output_directory = selected_file.replace('/Text files (*.txt)', '')
                elif metmessage.selected_format == 3:
                    create_METTA.acceptance_flag = 0
                    create_METCM.acceptance_flag = 0
                    selected_directory = dialog.selectedFiles()[0]
                    for files in file_list:
                        if selected_directory:
                            selected_file = selected_directory + '/' + f'{files}'
                        output_directory = selected_file.replace('/Text files (*.txt)', '')
            else:
                create_METCM.acceptance_flag = 1
                create_METTA.acceptance_flag = 1
            print(output_directory)

        except UnboundLocalError:
            pass


class FileManagerDialog_2(QDialog):
    def __init__(self):
        super().__init__()
        self.save_file_dialog()

    def save_file_dialog(self):
        global browsed_files, output_files
        try:
            dialog = QFileDialog(self)
            dialog.setFileMode(QFileDialog.FileMode.Directory)  # Allow selecting only directories
            dialog.setOption(QFileDialog.Option.ShowDirsOnly, True)  # Only show directories
            if dialog.exec() == QDialog.DialogCode.Accepted:
                create_METTA.acceptance_flag = 0
                create_METCM.acceptance_flag = 0
                selected_directory = dialog.selectedFiles()[0]
                if selected_directory:
                    output_files = []
                    for files in file_list:
                        index = file_list.index(files)
                        release_date = input_header[index]['ReleaseDate']
                        release_time = input_header[index]['ReleaseTime']

                        # Format date and time strings correctly
                        formatted_date = release_date[0].replace('/', '')
                        formatted_time = release_time[0].replace(':', '')

                        selected_file_metta = f"{selected_directory}/{formatted_date}-{formatted_time}UTC-METTA.txt"
                        selected_file_metcm = f"{selected_directory}/{formatted_date}-{formatted_time}UTC-METCM.txt"

                        output_files.append(selected_file_metta)
                        output_files.append(selected_file_metcm)

                    print(output_files)
            else:
                create_METCM.acceptance_flag = 1
                create_METTA.acceptance_flag = 1

        except UnboundLocalError:
            pass

class Ui_Dialog(object):
    def setupUi(self, Dialog):
        Dialog.setObjectName("Dialog")
        Dialog.setGeometry(0, 0, 1200, 900)
        Dialog.setWindowIcon(QtGui.QIcon("Images/M.png"))
        Dialog.setWindowFlag(QtCore.Qt.WindowType.WindowMaximizeButtonHint, True)
        Dialog.setWindowFlag(QtCore.Qt.WindowType.WindowMinimizeButtonHint, True)

        # Layout for the main window
        main_layout = QVBoxLayout(Dialog)
        button_layout = QHBoxLayout()

        # Create a stacked widget to switch between table and graph
        self.stacked_widget = QStackedWidget()

        # Table Widget Page
        self.table_page = QWidget()
        table_layout = QVBoxLayout(self.table_page)
        self.tableWidget = QTableWidget(parent=self.table_page)
        table_layout.addWidget(self.tableWidget)
        self.stacked_widget.addWidget(self.table_page)
        self.tableWidget.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)

        # Graph Page
        self.graph_page = QWidget()
        graph_layout = QVBoxLayout(self.graph_page)
        self.frame = QFrame(parent=self.graph_page)
        self.frame.setFrameShape(QtWidgets.QFrame.Shape.Panel)
        self.frame.setFrameShadow(QtWidgets.QFrame.Shadow.Sunken)
        graph_layout.addWidget(self.frame)
        self.stacked_widget.addWidget(self.graph_page)

        self.label = QtWidgets.QLabel()
        self.label.setFixedSize(400, 20)
        self.label.setText("Global Forecast System Data Table - Vertical Weather Profile")
        self.label.setScaledContents(True)
        self.label.setObjectName("label")

        # Button Box
        self.buttonBox = QtWidgets.QDialogButtonBox(parent=Dialog)
        self.buttonBox.setStandardButtons(
            QtWidgets.QDialogButtonBox.StandardButton.Cancel | QtWidgets.QDialogButtonBox.StandardButton.Ok)
        self.buttonBox.button(QtWidgets.QDialogButtonBox.StandardButton.Ok).setText("Generate MET Message")
        self.buttonBox.button(QtWidgets.QDialogButtonBox.StandardButton.Cancel).setText("Close")

        ok_button = self.buttonBox.button(QtWidgets.QDialogButtonBox.StandardButton.Ok)
        ok_button.setMinimumSize(150, 50)  # Adjust the size as needed
        ok_button.setMaximumSize(150, 50)  # Adjust the size as needed
        ok_button.clicked.connect(self.generate_MET)

        cancel_button = self.buttonBox.button(QtWidgets.QDialogButtonBox.StandardButton.Cancel)
        cancel_button.setMinimumSize(150, 50)  # Adjust the size as needed
        cancel_button.setMaximumSize(150, 50)  # Adjust the size as needed
        cancel_button.clicked.connect(Dialog.close)

        # Add navigation buttons
        self.prev_button = QPushButton("<", parent=Dialog)
        self.next_button = QPushButton(">", parent=Dialog)
        self.prev_button.setFixedSize(70, 50)
        self.next_button.setFixedSize(70, 50)

        self.change_button = QPushButton("Change", parent=Dialog)
        self.change_button.setFixedSize(100, 25)

        # Create TimeEdit widgets
        self.time_edit_start = QTimeEdit(parent=Dialog)
        self.time_edit_end = QTimeEdit(parent=Dialog)
        self.time_edit_start.setFixedSize(100, 25)
        self.time_edit_end.setFixedSize(100, 25)
        self.combobox = QComboBox(parent=Dialog)
        self.combobox.setFixedSize(100,25)


        # Optionally set default times

        # Add widgets to the button layout
        button_layout.addWidget(self.prev_button)
        button_layout.addWidget(self.label)
        button_layout.addWidget(self.next_button)
        button_layout.addWidget(self.combobox)
        button_layout.addWidget(self.time_edit_start)
        button_layout.addWidget(self.time_edit_end)
        button_layout.addWidget(self.change_button)

        main_layout.addLayout(button_layout)
        main_layout.addWidget(self.stacked_widget)
        main_layout.addWidget(self.buttonBox)

        self.retranslateUi(Dialog)
        QtCore.QMetaObject.connectSlotsByName(Dialog)

        # Set up table widget
        self.setup_table(df)

        # Set up graph
        self.setup_graph(df)

        # Connect page change signals to slots
        self.prev_button.clicked.connect(self.prev_page)
        self.next_button.clicked.connect(self.next_page)
        self.change_button.clicked.connect(self.change_time)
        self.change_button.setDisabled(True)

        self.label_list = ["Global Forecast System Data Table - Vertical Weather Profile",
                           "Vertical Weather Profile Data Parameters vs Height Graphs"]

        self.time_edit_start.setDisabled(True)
        self.time_edit_end.setDisabled(True)

        delta = self.parse_timedelta(input_time[0])
        print(file_list)
        print(time_zone)
        print(delta)

        time_first = delta + time_zone
        total_seconds = int(time_first.total_seconds())
        hours = total_seconds // 3600
        minutes = (total_seconds % 3600) // 60
        seconds = total_seconds % 60

        if len(input_time)>1:
            delta_2 = self.parse_timedelta(input_time[-1])
        else:
            delta_2 = delta + timedelta(hours = 1)

        time_second_2 = delta_2 + time_zone
        total_seconds_2 = int(time_second_2.total_seconds())
        hours_2 = total_seconds_2 // 3600
        minutes_2 = (total_seconds_2 % 3600) // 60
        seconds_2 = total_seconds_2 % 60

        # Create a QTime object

        self.time_edit_start.setMinimumTime(QtCore.QTime(hours, minutes))
        self.time_edit_start.setMaximumTime(QtCore.QTime(hours_2, minutes_2))
        self.time_edit_end.setMinimumTime(QtCore.QTime(hours, minutes))
        self.time_edit_end.setMaximumTime(QtCore.QTime(hours_2, minutes_2))
        self.time_edit_start.setTime(QtCore.QTime(hours, minutes))
        self.time_edit_end.setTime(QtCore.QTime(hours_2, minutes_2))

        tables.insert(0,df)

        self.combobox.currentIndexChanged.connect(self.change_combo)

        print(tables)

        for time in input_time:
            delta = self.parse_timedelta(time)
            time_first = delta + time_zone
            total_seconds = int(time_first.total_seconds())
            hours = total_seconds // 3600
            minutes = (total_seconds % 3600) // 60
            seconds = total_seconds % 60
            self.combobox.addItem((QtCore.QTime(hours, minutes)).toString("HH:mm"))


    def change_combo(self):
        index = int(self.combobox.currentIndex())
        self.setup_table(tables[index])
        self.plot(tables[index])


    def generate_MET(self):
        create_METTA.file_list = file_list
        create_METCM.file_list = file_list
        create_METTA.forecast_dates = []
        create_METCM.forecast_dates = []
        create_METTA.forecast_times = []
        create_METCM.forecast_times = []
        for header in input_header:
            create_METTA.forecast_dates.append(header['ReleaseDate'])
            create_METCM.forecast_dates.append(header['ReleaseDate'])
            create_METTA.forecast_times.append(header['ReleaseTime'])
            create_METCM.forecast_times.append(header['ReleaseTime'])
        print(create_METTA.forecast_dates)
        print(create_METTA.forecast_times)
        print(create_METTA.file_list)
        create_METTA.index = self.combobox.currentIndex()
        create_METCM.index = self.combobox.currentIndex()
        metmessage.open_met_dialog()
        if metmessage.selected_format == 1:
            print('METCM Selected')
            FileManagerDialog()
            create_METCM.create_message(input_header[self.combobox.currentIndex()], input_table[self.combobox.currentIndex()], output_directory)
        elif metmessage.selected_format == 2:
            print('METTA selected')
            FileManagerDialog()
            create_METTA.create_message(input_header[self.combobox.currentIndex()], input_table[self.combobox.currentIndex()], output_directory)
        elif metmessage.selected_format == 3:
            print('All Types - All Files selected')
            FileManagerDialog_2()
            for i in range(len(file_list)):
                create_METTA.create_message(input_header[i], input_table[i], output_files[2*i])
                create_METCM.create_message(input_header[i], input_table[i], output_files[2*i+1])
        else:
            print('No selection is done')

    def prev_page(self):
        current_index = self.stacked_widget.currentIndex()
        new_index = (current_index - 1) % self.stacked_widget.count()
        self.stacked_widget.setCurrentIndex(new_index)
        self.stacked_widget.repaint()
        self.label.setText(self.label_list[new_index])

    def next_page(self):
        current_index = self.stacked_widget.currentIndex()
        new_index = (current_index + 1) % self.stacked_widget.count()
        self.stacked_widget.setCurrentIndex(new_index)
        self.stacked_widget.repaint()
        self.label.setText(self.label_list[new_index])

    def setup_table(self, df):
        # Set the number of rows and columns in the QTableWidget
        self.tableWidget.setRowCount(df.shape[0])
        self.tableWidget.setColumnCount(df.shape[1])

        # Set the headers
        self.tableWidget.setHorizontalHeaderLabels(df.columns)

        # Iterate over the DataFrame and set the data in the QTableWidget
        for i in range(df.shape[0]):
            for j in range(df.shape[1]):
                item = QtWidgets.QTableWidgetItem(str(df.iloc[i, j]))
                self.tableWidget.setItem(i, j, item)

    def setup_graph(self, df):
        # Create a Matplotlib figure and canvas
        self.figure = Figure(figsize=(12, 8), dpi=100)  # Larger figure size for better visibility
        self.canvas = FigureCanvas(self.figure)
        layout = QVBoxLayout(self.frame)
        layout.addWidget(self.canvas)

        # Plot the graph
        self.plot(df)

    def plot(self, df):
        # Filter columns to plot (excluding specified columns)
        self.figure.clear()
        columns_to_plot = [col for col in df.columns if col not in ['HeightMSL', 'Lat', 'Lon', 'Elapsed time', 'Pm', 'HeightE']]

        num_plots = len(columns_to_plot)
        gs = gridspec.GridSpec(2, 3)  # Define a 2x4 grid for 2 horizontal and 4 vertical plots

        for i, column in enumerate(columns_to_plot):
            row = i // 3  # Determine row index
            col = i % 3   # Determine column index
            ax = self.figure.add_subplot(gs[row, col])  # Specify the grid location for each subplot
            ax.plot(df[column], df['HeightMSL'], label=column)
            ax.set_xlabel(column)
            ax.set_ylabel('HeightMSL')
            ax.set_title(f"{column} vs. HeightMSL")  # Add title to each subplot


        gs.tight_layout(self.figure, h_pad=2.0, w_pad=2.0)
        self.figure.subplots_adjust(hspace=0.5, wspace=0.3)# Adjust layout with equal padding
        self.canvas.draw()

    def parse_timedelta(self,time_str):
        from datetime import timedelta
        import re
        # Define a regex pattern to parse time strings like '1 day, 2:30:00' or '2:30:00'
        pattern = re.compile(
            r'((?P<days>\d+)\s+day[s]?,\s*)?(?P<hours>\d{1,2}):(?P<minutes>\d{1,2}):(?P<seconds>\d{1,2})'
        )
        match = pattern.match(time_str)
        if not match:
            raise ValueError(f"Invalid time format: '{time_str}'")

        time_params = {name: int(param) for name, param in match.groupdict(default='0').items()}
        return timedelta(**time_params)

    def change_time(self):
        global change_flag
        if change_flag == 0:
            self.time_edit_start.setEnabled(True)
            self.time_edit_end.setEnabled(True)
            self.change_button.setText('Set')
            change_flag = 1
        else:
            msg = QMessageBox()
            msg.setIcon(QMessageBox.Icon.Warning)
            msg.setText(
                "The data will be reprocessed according to selected time interval, do you confirm that?")
            msg.setWindowTitle("Warning")
            msg.setWindowIcon(QIcon("Images/warning.png"))
            # Add buttons to the message box
            msg.setStandardButtons(QMessageBox.StandardButton.Ok | QMessageBox.StandardButton.Cancel)
            # Execute the message box and get the user's response
            response = msg.exec()
            # Process the user's response
            if response == QMessageBox.StandardButton.Ok:
                delta = self.parse_timedelta(input_time[0])
                print(file_list)
                print(time_zone)
                print(delta)
                print(input_time)
                self.time_edit_start.setDisabled(True)
                self.time_edit_end.setDisabled(True)
                self.change_button.setText('Change')
                change_flag = 0
                msg.close()

                profilegenerator.input_wrf_time = str(self.time_edit_start.time())
                print(profilegenerator.table_set)


            else:
                self.time_edit_start.setDisabled(True)
                self.time_edit_end.setDisabled(True)
                self.change_button.setText('Change')
                change_flag = 0
                delta = self.parse_timedelta(input_time[0])
                print(file_list)
                print(time_zone)
                print(delta)

                time_first = delta + time_zone
                total_seconds = int(time_first.total_seconds())
                hours = total_seconds // 3600
                minutes = (total_seconds % 3600) // 60
                seconds = total_seconds % 60

                if len(input_time) > 1:
                    delta_2 = self.parse_timedelta(input_time[-1])
                else:
                    delta_2 = delta + timedelta(hours=1)

                time_second_2 = delta_2 + time_zone
                total_seconds_2 = int(time_second_2.total_seconds())
                hours_2 = total_seconds_2 // 3600
                minutes_2 = (total_seconds_2 % 3600) // 60
                seconds_2 = total_seconds_2 % 60

                # Create a QTime object
                self.time_edit_start.setTime(QtCore.QTime(hours, minutes))
                self.time_edit_end.setTime(QtCore.QTime(hours_2, minutes_2))
                msg.close()
                pass


    def retranslateUi(self, Dialog):
        _translate = QtCore.QCoreApplication.translate
        Dialog.setWindowTitle(_translate("Dialog", "Vertical Weather Profile"))

def open_dialog():
    Dialog = QtWidgets.QDialog()
    Dialog.setStyle(QtWidgets.QStyleFactory.create("Windows Vista"))
    ui = Ui_Dialog() 
    ui.setupUi(Dialog)
    Dialog.show()
    Dialog.exec()

